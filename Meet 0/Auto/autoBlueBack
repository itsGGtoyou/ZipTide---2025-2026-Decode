package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import org.firstinspires.ftc.vision.VisionPortal;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;

import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;


//import com.qualcomm.robotcore.util.Hardware;

import com.qualcomm.robotcore.robot.Robot;
import org.firstinspires.ftc.robotcore.external.JavaUtil;

@Autonomous(name="autoBlueBack", group="Linear Opmode")

public class autoBlueBack extends LinearOpMode {
  private ElapsedTime runtime = new ElapsedTime();
  private DcMotor backLeftM;
  private DcMotor backRightM;
  private DcMotor frontLeftM;
  private DcMotor frontRightM;
  private DcMotor intakeM;
  private DcMotor flywheel;
  private DcMotor flywheel2;

  private Servo gateS;
  
  private int newFrontLeftTarget;
  private int newFrontRightTarget;
  private int newBackLeftTarget;
  private int newBackRightTarget;
  private int newIntake;
  private int newLaunch;
  
  // private FirstVisionProcessor visionProcessor;
  private VisionPortal visionPortal;
  
  private double time1;
  private double time2;
  private double distance1;
  private double distance2;
    
  @Override
  public void runOpMode() throws InterruptedException {
      frontRightM = hardwareMap.get(DcMotor.class, "frontRightM");
      backRightM = hardwareMap.get(DcMotor.class, "backRightM");
      frontLeftM = hardwareMap.get(DcMotor.class, "frontLeftM");
      backLeftM = hardwareMap.get(DcMotor.class, "backLeftM");
      intakeM = hardwareMap.get(DcMotor.class, "intakeM");
      flywheel = hardwareMap.get(DcMotor.class, "flywheel");
      flywheel2 = hardwareMap.get(DcMotor.class, "flywheel2");
      gateS = hardwareMap.get(Servo.class, "gateS");
      
      frontRightM.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      backRightM.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      frontLeftM.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      backLeftM.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      intakeM.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      flywheel.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
      flywheel.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
      
      frontLeftM.setDirection(DcMotor.Direction.REVERSE);
      frontRightM.setDirection(DcMotor.Direction.REVERSE);
      backLeftM.setDirection(DcMotor.Direction.FORWARD);
      backRightM.setDirection(DcMotor.Direction.FORWARD);
      intakeM.setDirection(DcMotor.Direction.REVERSE);
      flywheel.setDirection(DcMotor.Direction.REVERSE);
      flywheel.setDirection(DcMotor.Direction.REVERSE);
      
      frontLeftM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      frontRightM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      backLeftM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      backRightM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      intakeM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      flywheel.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      flywheel.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
      
      
      waitForStart();
        
        closeGate();
        sleep(500);
        flywheel.setPower(0.69);
        sleep(8000);
        openGate();
        sleep(500);
        closeGate();
        sleep(500);
        sleep(5000);
        openGate();
        sleep(500);
        closeGate();
        sleep(500);
        sleep(5000);
        openGate();
        sleep(500);
        closeGate();
        sleep(500);
        
        drive(0.2, 15, 15, "straight");
        
        
        

    }


    private void reset(){
      backLeftM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
      backRightM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
      frontLeftM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
      frontRightM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
      intakeM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
      flywheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
      flywheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
    }
    
    private void drive(double speed, int leftTarget, int rightTarget, String direction) {
      reset();
      leftTarget *= 45;
      rightTarget *= 45;
      
      newFrontLeftTarget = leftTarget;
      newFrontRightTarget = rightTarget;
      newBackLeftTarget = leftTarget;
      newBackRightTarget = rightTarget;
      
      if(direction == "straight") {
        frontLeftM.setTargetPosition(newFrontLeftTarget);
        frontRightM.setTargetPosition(newFrontRightTarget);
        backLeftM.setTargetPosition(newBackLeftTarget);
        backRightM.setTargetPosition(newBackRightTarget);
        telemetry.addData("Moving", "straight");
        telemetry.update();
      } else if (direction == "left") {
        frontLeftM.setTargetPosition(-newFrontLeftTarget);
        frontRightM.setTargetPosition(newFrontRightTarget);
        backLeftM.setTargetPosition(newBackLeftTarget);
        backRightM.setTargetPosition(-newBackRightTarget);
        telemetry.addData("Moving", "left");
        telemetry.update();
      } else if (direction == "right") {
        frontLeftM.setTargetPosition(newFrontLeftTarget);
        frontRightM.setTargetPosition(-newFrontRightTarget);
        backLeftM.setTargetPosition(-newBackLeftTarget);
        backRightM.setTargetPosition(newBackRightTarget);
        telemetry.addData("Moving", "right");
        telemetry.update();
      }
        
      frontLeftM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
      frontRightM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
      backLeftM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
      backRightM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
      
      frontLeftM.setPower(speed);
      frontRightM.setPower(speed);
      backLeftM.setPower(speed);
      backRightM.setPower(speed);
        
        
        while(opModeIsActive() && frontLeftM.isBusy() && frontRightM.isBusy() && backLeftM.isBusy() && backRightM.isBusy()) {
          telemetry.addData("Path1",  "Running to %7d :%7d %7d :%7d", newFrontLeftTarget,  newFrontRightTarget, newBackLeftTarget, newBackRightTarget);
          telemetry.addData("Path2",  "Running at %7d :%7d :%7d :%7d", frontLeftM.getCurrentPosition(), frontRightM.getCurrentPosition(), backLeftM.getCurrentPosition(), backRightM.getCurrentPosition());
            telemetry.update();
        }  
        sleep(300);
    }


    private void intake(int intake) {
      reset();
      intake *= 45;
      
      newIntake = intake;
      
      intakeM.setTargetPosition(newIntake);
      telemetry.addData("scooping...", "INTO THE ROBOT");
      telemetry.update();
        
      intakeM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
      
      intakeM.setPower(0.7);
          
      while(opModeIsActive() && intakeM.isBusy() && flywheel.isBusy()) {
        telemetry.addData("Path1",  "Running to %7d :%7d %7d :%7d", newIntake);
        telemetry.addData("Path2",  "Running at %7d :%7d :%7d :%7d", intakeM.getCurrentPosition());
        telemetry.update();
      }
      sleep(300);
    }

    private void launch(double power) {
      reset();
      //launch *= 45;
      
      //newLaunch = launch;

      //flywheel.setTargetPosition(newLaunch);
      telemetry.addData("weeeeeeee!", "up up and awayyy");
      telemetry.update();
        
     // flywheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
      
      flywheel.setPower(power);
          
      while(opModeIsActive() && intakeM.isBusy() && flywheel.isBusy()) {
        telemetry.addData("Path1",  "Running to %7d :%7d %7d :%7d", newLaunch);
        telemetry.addData("Path2",  "Running at %7d :%7d :%7d :%7d", flywheel.getCurrentPosition());
        telemetry.update();
      }
      
      sleep(5000);

    }
    

    
    public void openGate(){
      gateS.setPosition(1);
    }
    public void closeGate(){
      gateS.setPosition(0.8);
    }
    
    // public void rpmTacker(){
      
    // }
    // public void fullLaunch(double power, int launch){
    //   // openGate();
    //   // sleep(1000);
    //   launch(power, launch);
    //   sleep(1000);
    //   openGate();
    //   sleep(500);
    //   closeGate();
    //   sleep(500);
    // }
}
