package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;
//import com.qualcomm.robotcore.util.Hardware;

import com.qualcomm.robotcore.robot.Robot;
import org.firstinspires.ftc.robotcore.external.JavaUtil;

@Autonomous(name="Meet0Auto", group="Linear Opmode")

public class Meet0Auto extends LinearOpMode {
    private ElapsedTime runtime = new ElapsedTime();
    private DcMotor backLeftM;
    private DcMotor backRightM;
    private DcMotor frontLeftM;
    private DcMotor frontRightM;
    private DcMotor intakeM;
    private DcMotor flywheel;

    private Servo gateS;
    
    private int newFrontLeftTarget;
    private int newFrontRightTarget;
    private int newBackLeftTarget;
    private int newBackRightTarget;
    
    @Override
    public void runOpMode() throws InterruptedException {
        frontRightM = hardwareMap.get(DcMotor.class, "frontRightM");
        backRightM = hardwareMap.get(DcMotor.class, "backRightM");
        frontLeftM = hardwareMap.get(DcMotor.class, "frontLeftM");
        backLeftM = hardwareMap.get(DcMotor.class, "backLeftM");
        intakeM = hardwareMap.get(DcMotor.class, "intakeM");
        flywheel = hardwareMap.get(DcMotor.class, "flywheel");
        
        frontRightM.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        backRightM.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        frontLeftM.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        backLeftM.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        intakeM.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        flywheel.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        
        frontLeftM.setDirection(DcMotor.Direction.REVERSE);
        frontRightM.setDirection(DcMotor.Direction.FORWARD);
        backLeftM.setDirection(DcMotor.Direction.REVERSE);
        backRightM.setDirection(DcMotor.Direction.FORWARD);
        intakeM.setDirection(DcMotor.Direction.REVERSE);
        flywheel.setDirection(DcMotor.Direction.REVERSE);
        
        frontLeftM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRightM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backLeftM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backRightM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        intakeM.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        flywheel.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
         
        
        waitForStart();

    }
  private void reset(){
        backLeftM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backRightM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontLeftM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontRightM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        intakeM.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        flywheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
    }
  private void drive(double speed, int leftTarget, int rightTarget, String direction) {
        reset();
        leftTarget *= 45;
        rightTarget *= 45;
        
        newFrontLeftTarget = leftTarget;
        newFrontRightTarget = rightTarget;
        newBackLeftTarget = leftTarget;
        newBackRightTarget = rightTarget;
        
        if(direction == "straight") {
            frontLeftM.setTargetPosition(newFrontLeftTarget);
            frontRightM.setTargetPosition(newFrontRightTarget);
            backLeftM.setTargetPosition(newBackLeftTarget);
            backRightM.setTargetPosition(newBackRightTarget);
            telemetry.addData("Moving", "Right");
            telemetry.update();
        } else if (direction == "left") {
            frontLeftM.setTargetPosition(-newFrontLeftTarget);
            frontRightM.setTargetPosition(newFrontRightTarget);
            backLeftM.setTargetPosition(newBackLeftTarget);
            backRightM.setTargetPosition(-newBackRightTarget);
            telemetry.addData("Moving", "Right");
            telemetry.update();
        } else if (direction == "right") {
            frontLeftM.setTargetPosition(newFrontLeftTarget);
            frontRightM.setTargetPosition(-newFrontRightTarget);
            backLeftM.setTargetPosition(-newBackLeftTarget);
            backRightM.setTargetPosition(newBackRightTarget);
            telemetry.addData("Moving", "Right");
            telemetry.update();
        }
        
        frontLeftM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRightM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeftM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRightM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        
        frontLeftM.setPower(speed);
        frontRightM.setPower(speed);
        backLeftM.setPower(speed);
        backRightM.setPower(speed);
        
        
        while(opModeIsActive() && frontLeftM.isBusy() && frontRightM.isBusy() && backLeftM.isBusy() && backRightM.isBusy()) {
            telemetry.addData("Path1",  "Running to %7d :%7d %7d :%7d", newFrontLeftTarget,  newFrontRightTarget, newBackLeftTarget, newBackRightTarget);
            telemetry.addData("Path2",  "Running at %7d :%7d :%7d :%7d",
                        frontLeftM.getCurrentPosition(),
                        frontRightM.getCurrentPosition(),
                        backLeftM.getCurrentPosition(),
                        backRightM.getCurrentPosition());
            telemetry.update();
        }
        sleep(300);
    }

    private void artifact(double speed, String direction) {
        reset();
        intake *= 45;
        outtake *= 45;
        
        newIntake = intake;
        newOuttake = outtake;
        
        if(direction == "in") {
            intakeM.setTargetPosition(newIntake);
            flywheel.setTargetPosition(0);
            telemetry.addData("scooping up");
            telemetry.update();
        } else if (direction == "out") {
            flywheel.setTargetPosition(newOuttake);
            intakeM.setTargetPosition(0);
            telemetry.addData("launching");
            telemetry.update();
        }
        
        intakeM.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        flywheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        
        intakeM.setPower(speed);
        flywheel.setPower(speed);
        
        
        while(opModeIsActive() && intakeM.isBusy() && flywheel.isBusy()) {
            telemetry.addData("Path1",  "Running to %7d :%7d %7d :%7d", newIntake,  newOuttake);
            telemetry.addData("Path2",  "Running at %7d :%7d :%7d :%7d",
                        intakeM.getCurrentPosition(),
                        flywheel.getCurrentPosition());
            telemetry.update();
        }
        sleep(300);
    }
  
  

  
}
